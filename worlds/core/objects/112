112
0
1

10
level
(0)
7
0
0
5
.
name
("Code Utilities")
7
0
0
5
.
pubread
(0)
7
0
0
5
.
pubwrite
(0)
7
0
0
5
.
fertile
(1)
7
0
0
5
.
owner
(#7)
7
0
0
5
.
location
(#7)
7
0
0
5
.
aliases
(("Code Utilities"))
7
0
0
5
.
description
("Code Utilities")
7
0
0
5
.
contents
(())
112
0
0
5
.
5
macro-letf

.
7
0
oThis pNone oThis
5
.
make-extractor

.
7
0
oThis pNone oThis
5
.
loop
(let ((form args))
  (if (not (= (len form) 4))
      (err E_ARGS (cat "loop takes 4 arguments (" (len form)" provided: " form ".)"))
      (let ((loopvars (get form 0))
            (initvals (get form 1))
            (cont-symbol (get form 2))
            (body (get form 3)))
        (if (not (istype loopvars "sym"))
            (err E_ARGS "first argument to loop must be a symbol")
            nil)
        (if (not (istype initvals "list"))
            (err E_ARGS "second argument to loop must be a list")
            nil)
        (if (not (istype cont-symbol "sym"))
            (err E_ARGS "third argument to loop must be a symbol")
            nil)
        `(let ((_CONT (call-cc (lambda (cont)
                                 (cont (list cont ,initvals)))))
               (,loopvars (get _CONT 1))
               (,cont-symbol (lambda (vals)
                               ;; avoid nasty surprises
                               (let ((realvals (if (istype vals "list") vals (list vals)))
                                     (continuation (get _CONT 0)))
                                 (call continuation (list (list continuation realvals)))))))
           ,body))))
.
7
0
oThis pNone oThis
5
.
setf
(if (not (= (len args) 2))
    (err E_ARGS "setf takes exactly 2 arguments")
    (let ((loc     (get args 0))
          (new-val (get args 1)))
      (cond
       ((istype loc "sym")
        (err E_ARGS "cannot setf an arbitrary symbol"))
       ((or (not (istype loc "list") (> (len loc) 1)))
        (err E_ARGS (cat "what could you possibly hope setf'ing " loc " would achieve?")))
       ((let ((fst
.
7
0
oThis pNone oThis
5
.
pcase
(let ((unify-literal
       (lambda (exp args match-handler err-handler)
         (let ((literal (get args 0)))
           (if (= literal exp)
               '()
               (unify-error-mismatch literal exp err-handler)))))

      (pcase-special-table
       (table '(literal (("sym") unify-literal))
              '(rest    (("sym") unify-rest))))

      (special-symbols
       (lambda (special-table)
         (map (lambda (x) (symbol (cat "&" ($ (head x))))) (tpairs special-table))))

      (unify-error-mismatch
       (lambda (exp pat err-handler)
         (err-handler 'mismatch "Mismatch" pat exp)))

      (unify-mismatch-ignoring-handler
       (lambda (err-handler)
         (lambda (err-type helpstr pat exp)
           (unless (= err-type 'mismatch)
             (err-handler err-type helpstr pat exp)))))

      (unify-list
       ;; err-handler is a function that takes 4 arguments:
       ;; error kind, reason, the pattern, the expression that didn't match.
       (lambda (exp listpat match-handler err-handler)
         (if (= 0 (len listpat))
             (if (= exp listpat)
                 '()
                 (unify-error-mismatch exp listpat err-handler))
             (let ((phead (head listpat)))
               (if (and (istype phead "sym") (= "&" (substr ($ phead) 0 0)))
                   (let ((special-name (substr ($ phead) 1 -1))
                         (special-entry (tget pcase-special-table special-name nil)))
                     (when (nil? special-entry)
                       (err-handler 'unknown-special-pattern
                                    (cat "Invalid special pattern " listpat ".")
                                    listpat exp))
                     (let ((types (get special-entry 0))
                           (fn (get special-entry 1))
                           (patargs (tail listpat)))
                       (call fn patargs)
                       ))
                   (if (istype exp "list")
                       (do
                           (unify (head exp) phead match-handler err-handler)
                           (unify-list (tail exp) (tail listpat) match-handler err-handler))
                       (unify-error-mismatch exp listpat err-handler)))))))

      (unify
       (lambda (exp pat match-handler err-handler)
         (cond
          ((and (istype pat "list"))
           (unify-list exp pat match-handler err-handler))
          ((istype pat "sym") (match-handler pat exp))
          ((err-handler 'malformed-pattern "Malformed pattern" pat exp))))))

  (let ((ct (call-cc (lambda (x)
                       (list () () x)))))
    (if (= 2 (len ct))
        ((get ct 0) (get ct 1))
        (let ((matches (get ct 0))
              (errors (get ct 1))
              (continuation (get ct 2)))
          (unify '(a b c) '(1 2 3)
                 (lambda (sym val)
                   (continuation (push matches (sym val))
                                 errors
                                 continuation))
                 (lambda (err-type helpstr pat exp)
                   (continuation matches
                                 (push errors '(err-type helpstr pat exp)))))))))
.
7
0
oNone pNone oNone
5
.
